---
title: linear_model_analysis 
output: 
  html_document:
    toc: yes
    toc_float: yes
---

```{r }
rm(list = ls())
knitr::opts_chunk$set(eval = T, cache = T, message = F, warning=F)
library(dplyr)
library(magrittr)
library(ggplot2)
library("gridExtra")
library("cowplot")
library(car)
library(FactoMineR)
library(ade4)
library(vegan)
library(MASS)
library(ellipse)
library(smatr)
library(TeachingDemos)

source("https://raw.githubusercontent.com/talgalili/R-code-snippets/master/boxplot.with.outlier.label.r") # Load the function for outliers label


path <- "C:\\Users\\emduc\\Desktop\\Drive\\symphostage\\"
# path <- "./data/" # To be used on sylvain local machine
```

# data

```{r}
trait <- read.csv(file.path(path, "environment_trait2.csv"),header = T, dec = ".", sep=",") %>% 
  dplyr::select(-PointWeight, -nNeighbors, -GNeighbors, -wood_presence, -NomForet, -idArbre, -Y, -X, -Branch_diameter, -Bark_thickness, -Bark_infra_density, -Wood_infra_density)

topo <- read.csv(file.path(path, "topo_sympho.csv"),header = T, dec = ".", sep=";") 

topo <- topo %>% 
  dplyr::filter(TypeTopoEN !="")  

trait1 <- trait  %>% 
  mutate(Dawkins = as.factor(as.character(Dawkins))) %>% 
  full_join(topo) %>% 
  dplyr::select(n_parcelle, n_carre, n_arbre,SLA, LT_mean, Chloro_content, LMDC,Area_exclude , d_creek, wetness, TypeTopoEN, Dawkins, dem, slope, TRI, aspect, curvature, d_log_gap, Competition, diameter) %>% 
  dplyr::filter(!is.na(TypeTopoEN))
```
In the following text, the terms descriptors and varaible will be used interchangeably. These refereing to the attributes (not in the functional way), or character used to describe or compoare the object of the study.

## spotting outliers 


```{r}

trait <- trait %>% 
  mutate(ID= paste(n_parcelle, n_carre, n_arbre, sep="_"))

outliers_name <- trait$ID
```
###SLA
```{r}
boxplot.with.outlier.label(trait$SLA,outliers_name)%$% 
data.frame(ID = outlier_df$label_name)  %>%  inner_join(trait)


```
So there is four outliersaccording to boxplot analysis, 11-1-742 and 11-4-983 have really abberrant value whereas 13-2-73 and 15-1-198 can be consider are maximum range value for SLA. 

```{r}
trait <- trait %>% 
  filter(SLA < 400)

```

###LMDC
```{r}
outliers_name <- trait$ID
boxplot.with.outlier.label(trait$LMDC,outliers_name) %$% 
data.frame(ID =outlier_df$label_name) %>%  inner_join(trait) 


```
So there are 7 value that are consider as outliers, here we decide to remove the individuals 
```{r}
trait <- trait %>% 
  filter(!(LMDC < 0.25 |LMDC > 0.45))
```

### LT_mean

```{r}
outliers_name <- trait$ID
boxplot.with.outlier.label(trait$LT_mean,outliers_name)

```
FOr Lt_mean there is no outliers ! 

### Chloro content
```{r}
boxplot.with.outlier.label(trait$Chloro_content,outliers_name)%$% 
data.frame(ID= outlier_df$label_name) %>%  inner_join(trait)
```

there is one outlier so we removed it 

```{r}
trait <- trait %>% 
  filter(! Chloro_content < 40.5)
```

### Area 

```{r}
outliers_name <- trait$ID
boxplot.with.outlier.label(trait$Area_exclude,outliers_name)%$% 
data.frame(ID = outlier_df$label_name)%>%  inner_join(trait) 
```

Normaly when no individual are removed after outlier spotting there are 20 individuals which are consider as Area outlier, here it is more difficult to know if we need to remove it becaus some individual have extramly big leaves .. but maybe it is due to an ontogenic effect and so it would be better to remove them.

```{r}
trait <- trait %>% 
  filter(!Area_exclude > 54)
```


## standardisation 

all variable have been reduce and centered by z-score method to have demensionless variables.
  
```{r}

trait_standar <- trait %>%
  dplyr::select(n_parcelle, n_carre, n_arbre,LT_mean, Chloro_content, LMDC, SLA, Area_exclude) %>% 
  
  mutate(LT_mean = (LT_mean-(mean(trait$LT_mean))/sd(trait$LT_mean))) %>% 
  
  mutate(Chloro_content = (Chloro_content-(mean(trait$Chloro_content))/sd(trait$Chloro_content))) %>% 
  
  mutate(SLA= (SLA - (mean(trait$SLA))/sd(trait$SLA))) %>% 
  
  mutate(Area = (Area_exclude-(Area_exclude-mean(trait$Area_exclude))/ sd(trait$Area_exclude))) %>%
  
  dplyr::select(-Area_exclude)

environment_standar <- trait %>% 
  dplyr::select(n_parcelle, n_carre, n_arbre,wetness,Competition,   d_creek, aspect, curvature, TRI, diameter,dem,slope, Dawkins, d_log_gap) %>% 
  mutate( diameter= (diameter- (mean(trait$diameter))/sd(trait$diameter))) %>% 
  mutate( d_creek= (d_creek- (mean(trait$d_creek))/sd(trait$d_creek))) %>%
  mutate( wetness= (wetness-(mean(trait$wetness))/sd(trait$wetness))) %>% 
  mutate( dem= (dem-(mean(trait$dem))/sd(trait$dem))) %>% 
  mutate( slope= (slope-(mean(trait$slope))/sd(trait$slope))) %>%
  mutate( TRI= (TRI-(mean(trait$TRI))/sd(trait$TRI))) %>%
  mutate( curvature= (curvature-(mean(trait$curvature))/sd(trait$curvature))) %>%
  mutate( aspect= (aspect-(mean(trait$aspect))/sd(trait$aspect))) %>%
  mutate( Competition= (Competition-(mean(trait$Competition))/sd(trait$Competition))) %>% 
mutate( d_log_gap= (d_log_gap-(mean(trait$d_log_gap))/sd(trait$d_log_gap)))
#, TypeTopoEN

```



## descriptors selection


function to print coeficient of correlation on a pairs plot with an significant test. Here we choose to use Spearman correlation because every environmental data are not independant. 

```{r}
panel.cor <- function(x, y, digits=2, prefix="", cex.cor) {
  usr <- par("usr")
  on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- abs(cor(x, y, use = "complete.obs", method = "spearman"))
  txt <- format(c(r, 0.123456789), digits = digits)[1]
  txt <- paste(prefix, txt, sep = "")
  if (missing(cex.cor)) cex <- 0.8 / strwidth(txt)

  test <- cor.test(x, y)
  # borrowed from printCoefmat
  Signif <- symnum(
    test$p.value, corr = FALSE, na = FALSE,
    cutpoints = c(0, 0.05, 0.1, 1),
    symbols = c("*", ".", " ")
  )

  text(0.5, 0.5, txt, cex = cex * r)
  text(.8, .8, Signif, cex = cex, col = 2)
}
pairs(environment_standar[,4:10], lower.panel = panel.smooth, upper.panel = panel.cor)

```

A we can see on the plot that TRI and wetness are highly correlated so we need to choose one wetness seems bring more ecological information thant TRI it will be selected. Also diameter,  Competition index are really correlated, here competition bring a special information that can not be removed and diameter is in a way summarised in the competition index because it is based on the basal area that is calculated with DBH. 

```{r}
environment_standar <- environment_standar %>% 
  dplyr::select(-TRI , -diameter)

pairs(environment_standar[,4:10], lower.panel = panel.smooth, upper.panel = panel.cor)
```


Then I need to choose between dem, slope and wetness as the wetness index is derivated from dem and other topographic information like slope so all the information is summarised in wetness.

```{r}
environment_standar <- environment_standar %>% 
  dplyr::select(-slope, -dem)

pairs(environment_standar[,4:10], lower.panel = panel.smooth, upper.panel = panel.cor)
```
SO now there is a hudge correlation between d_log_gap and d_creek due to bottom land is not exploitable so logging gap had been done with a certain distance from those area. D_creek give a better ecological information, than d_log_gap because exploitation had been done sevral years ago and do not longer impact leaf functionnal trait due to the reduce leaf life span. 

Wetness and type topo are correlated and as wetness is a derivative analysis of topographic information it would be better to choose it because topographic information is preserve.

Finally Dawkins to competition don't know, it would be better with d_gap because without Dawkins wa lost light information that cannot be extract from competition even if they are correlated. 


```{r}
environment_standar <- environment_standar %>% 
  dplyr::select(-d_log_gap,  -Dawkins)

pairs(environment_standar[,4:8], lower.panel = panel.smooth, upper.panel = panel.cor) %>% summary
```


```{r}
library(faraway)
sort(vif(environment_standar) )
```

Borcard et al. 2011: 175 argue that in the case of RDA, VIFs > 10 should be avoided, so here everything is right. 



## descriptors distribution 
### environment
```{r}
wetness <- ggplot(environment_standar, aes((wetness)))+
  geom_histogram(na.rm = T)

competition <- ggplot(environment_standar, aes((Competition)))+
  geom_histogram(na.rm = T)

d_creek <- ggplot(environment_standar, aes((d_creek)))+
  geom_histogram(na.rm = T)

aspect <- ggplot(environment_standar, aes((aspect)))+
  geom_histogram(na.rm = T)

curvature <- ggplot(environment_standar, aes((curvature)))+
  geom_histogram(na.rm = T)

plot_grid(wetness, competition, d_creek, aspect,curvature   , labels=c("A", "B","C", "D"), ncol = 2, nrow = 3)
```

# lm 

Using standardized data and only uncorrelated data to avoid singularities error in multiplicative model 



```{r}
data_standar <- full_join(environment_standar,trait_standar) %>%
  
  dplyr::select(-n_parcelle, -n_carre, -n_arbre) 

data_standar$Dawkins <- trait$Dawkins
```

## SLA
###  test normality

```{r SLA normality}
qqnorm(sqrt(trait_standar$SLA),datax=TRUE)
abline(qqline(trait_standar$SLA),datax=TRUE)
hist(sqrt(trait_standar$SLA))
shapiro.test(trait_standar$SLA)
```

Accordindg to shapiro test SLA distribution is not normal even if with QQ plot it seems to be normal. Also log transformation does not improve normality assumption whereas it seems to work in some papers like Lajoie & Vellen 2015 or log10 like in Vajardero and Piper 2010 or Wright et al 2007. And other transfromation for left-skewed distribution also are not efficient. 

### step both


```{r}

data_standar3 <- data_standar %>% 
  dplyr::select(-Area, -LMDC, -LT_mean)

SLA_model <-  lm(SLA~., data= data_standar3)
step(object = SLA_model, direction = "both")

lm(formula = SLA ~ Competition + d_creek + Chloro_content + Dawkins, 
    data = data_standar3) %>% summary

# lm(formula = SLA ~ d_creek * Dawkins  * LT_mean +
#     Chloro_content * LMDC, data = data_standar3) %>% summary
```


here multiplicative model with the same pre-selected variables from step have a better adjusted Rsquarred than the additive one respectiveky 0.7152 and 0.7066 butI don't think that the difference is really significant. 

### step forward

```{r}
step(object = SLA_model, direction = "forward")
lm(formula = SLA ~ LT_mean + Chloro_content + LMDC + d_creek + 
    wetness + TypeTopoEN + Dawkins + dem + slope + TRI + aspect + 
    curvature + d_log_gap, data = trait) %>% summary # forward
```
 The forwar analysis seems to do some mistake when we summarize the call formula.. 

### step backward

```{r}
step(object = SLA_model, direction = "backward")
lm(formula = SLA ~ LT_mean + Chloro_content + LMDC + d_creek + 
    Dawkins + d_log_gap, data = trait) %>%  summary# backward
```

with the backwar analysis we have the same result than "both" step method. th adjusted R-squared is 0.7086 , a quite good value 


## LMDC
### normality test


```{r}
shapiro.test((trait_standar$LMDC))
qqnorm(trait_standar$LMDC,datax=TRUE) 
abline(qqline(trait_standar$LMDC,datax=TRUE))
hist(trait_standar$LMDC)
```


### step both

```{r}
 data_standar2<- data_standar %>%
  dplyr::select(-SLA) 
  
LMDC_model <- lm(LMDC~., data=data_standar2)
step(object = LMDC_model, direction = "both")

lm(formula = LMDC ~ Competition + curvature + Area_exclude + 
    Chloro_content + Dawkins, data = data_standar2) %>% summary

   # lm(formula = LMDC ~ Competition *curvature* Area_exclude * Chloro_content* Dawkins, data = data_standar2 ) %>%  summary()
```
here with the selected variable from step put in an multiplicative model there is no significant interaction and the adjusted R-squared is  0.4173 whereas with the additive model the adjusted R-squared is   0.4294 . So as there is no significant interaction the additive model will be selected. 

### step backwar

```{r}
#step(object = LMDC_model, direction = "backward")

```

### step forward


```{r}
#step(object = LMDC_model, direction = "forward")

```

Backward method is better Adjusted R-squared:  0.3919 

## LT

###normality test 

```{r}
ks.test(data_standar$LT_mean, "pnorm")
shapiro.test(data_standar$LT_mean) 
hist((data_standar$LT_mean))
qqnorm(trait$LT_mean,datax=TRUE)
abline(qqline(trait$LT_mean,datax=TRUE))
```


### step both


```{r}
LT_mean_model <- lm(LT_mean~., data=data_standar2)
step(object = LT_mean_model, direction = "both")

lm(formula = LT_mean ~ Competition + curvature + Area_exclude + 
    Dawkins, data = data_standar2) %>%  summary

 # lm(formula = LT_mean ~ curvature * 
 #     Dawkins * Area_exclude* Competition , data = data_standar2) %>%  summary()
```
the multiplicative form does not show any interesting interaction between variable and have a smaller adjusted R-squared : 0.2582 against 0.267
### step backward

```{r}
step(object = LT_mean_model, direction = "backward")

lm(formula = LT_mean ~ wetness + diameter + dem + TypeTopoEN + 
    Dawkins + Chloro_content, data = data_standar2) %>% summary()
```

### step forward


```{r}
step(object = LT_mean_model, direction = "forward")

lm(formula = LT_mean ~ wetness + Competition + d_creek + aspect + 
    curvature + TRI + diameter + dem + slope + TypeTopoEN + Dawkins + 
    d_log_gap + Chloro_content + LMDC, data = data_standar2)%>% summary()
```

Once again forward method does not work well and result from both method is the same than the backward one. And Adjusted R-squared:  0.3322 



## chloro content
using data standar with SLA value because chlorocontent is not correlated or a component of SLA
### normality test 

```{r normality chloro}
shapiro.test(data_standar$Chloro_content) 
hist(data_standar$Chloro_content)
qqnorm(trait$Chloro_content,datax=TRUE)
abline(qqline(trait$Chloro_content,datax=TRUE))
```


### step both

```{r}

Chloro_content_model <- lm(Chloro_content~., data=data_standar3)
step(object = Chloro_content_model, direction = "both")

truc <- lm(formula = Chloro_content ~ wetness + Competition + aspect + 
    LT_mean + LMDC + SLA, data = data_standar3) %>%  summary() 

plot(lm(formula = Chloro_content ~ wetness + Competition + aspect + 
    LT_mean + LMDC + SLA, data = data_standar3))



 lm(formula = Chloro_content ~ Competition * aspect *  LMDC * SLA+ LT_mean, data = data_standar) %>%  summary()
 
 

```
aspect is selected by step function but it is not significant when lm is applied alone ..

Multiplicative form give almost the same adjusted R-squared but there are just a few significant variables and interactions. 


### step backward
```{r}
step(object = Chloro_content_model, direction = "backward")

lm(formula = Chloro_content ~ Competition + aspect + diameter + 
    dem + LMDC + SLA, data = data_standar) %>% summary()
```
Same result as both direction 

### step forward

```{r}
step(object = Chloro_content_model, direction = "forward")

lm(formula = Chloro_content ~ wetness + Competition + d_creek + 
    aspect + curvature + TRI + diameter + dem + slope + TypeTopoEN + 
    Dawkins + d_log_gap + LT_mean + LMDC + SLA, data = data_standar)%>% summary()
```

Once again forward method does not work well and result from both method is the same than the backward one. And Adjusted R-squared:  0.3176




## area

```{r}
shapiro.test((log(trait_standar$Area)))
qqnorm(log(trait_standar$Area),datax=TRUE) 
abline(qqline(log(trait_standar$Area),datax=TRUE))
hist(log(trait_standar$Area))

```

#  SMA
"Relationship strength was quantified using correlation r2 and P values; relationship
sample sizes given in Table 2). Relationship strength was quantified using correlation r2 and P values; relationship
slopes were described by their standardized major axes
(SMAs). SMA analyses are appropriate when the purpose
of line-fitting is to summarize the relationship between
two variables, as in many allometric studies (Sokal and
Rohlf, 1995). An SMA line is the slope of the first princi-pal axis in a PCA analysis based on standardized data,
fitted through the centroid of the data. SMA routines
were run in a DOS-based computer package, (S)MATR
(Falster et al., 2003)." Wright et al, 2007

```{r}
test <- sma(SLA~LMDC, data=data_standar) 
summary(test)
plot(test, col ="purple")
abline((lm(data_standar$SLA~data_standar$LMDC)))
```



#rda 
## analysis

If lm part is not run before you need to remove n_parcelle, n_carre and n_arbre from trait_standar and environment_standar

```{r}
 trait_standar2 <- trait_standar %>% 
  dplyr::select(-n_parcelle, -n_carre, -n_arbre)
environment_standar2 <- environment_standar %>% 
  dplyr::select(-n_parcelle, -n_carre, -n_arbre)

rda_trait <- rda(trait_standar2~.,environment_standar2,scale = T, na.omit= T)
summary(rda_trait)

```

Now rda model validation 
```{r}
coef(rda_trait)
set.seed(111)
anova.cca(rda_trait, step=1000)
anova.cca(rda_trait, by="axis", step= 1000)
```

rda result plot

```{r}
plot(rda_trait, scaling = 0.5, main = "Triplot RDA scaling 1 - wa scores")
var.sc <- scores(rda_trait, choices = 1:2, scaling = 1, display = "species")

arrows(0, 0, var.sc[, 1], var.sc[,2], length = 0, lty = 1, col = "red")
```

